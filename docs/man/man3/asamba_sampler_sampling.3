.TH "asamba.sampler.sampling" 3 "Mon May 15 2017" "ASAMBA" \" -*- nroff -*-
.ad l
.nh
.SH NAME
asamba.sampler.sampling \- 
.SS ""
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SS ""
 

.SH SYNOPSIS
.br
.PP
.PP
Inherits \fBasamba\&.star\&.star\fP\&.
.PP
Inherited by \fBasamba\&.artificial_neural_network\&.neural_net\fP, and \fBasamba\&.interpolator\&.interpolation\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "def \fB__init__\fP (self)"
.br
.ti -1c
.RI "def \fBset\fP (self, attr, val)"
.br
.RI "Setter\&. "
.ti -1c
.RI "def \fBload_sampling_from_inlist\fP (self, filename)"
.br
.ti -1c
.RI "def \fBget\fP (self, attr)"
.br
.RI "Getter\&. "
.ti -1c
.RI "def \fBbuild_learning_set\fP (self)"
.br
.RI "Methods\&. "
.ti -1c
.RI "def \fBlearning_log_Teff_log_g\fP (self)"
.br
.ti -1c
.RI "def \fBsplit_learning_sets\fP (self)"
.br
.ti -1c
.RI "def \fBget_M_ini_fov_Z_logD_Xc_from_models_id\fP (self, list_ids_models)"
.br
.ti -1c
.RI "def \fBextract_gyre_modes_from_id_model_id_rot\fP (self, list_ids_models, list_ids_rot, list_rows)"
.br
.ti -1c
.RI "def \fBtrim_closest_modes\fP (modes, rec_gyre, dic_mode_types, trim_delta_freq_factor)"
.br
.RI "Trimming Functions Note: The signatures of the following three functions must be identical, because they are tossed into self\&.search_function, and can be called from external (inherited) modules\&. "
.ti -1c
.RI "def \fBtrim_modes_by_dP\fP (modes, rec_gyre, dic_mode_types, trim_delta_freq_factor)"
.br
.ti -1c
.RI "def \fBtrim_modes_by_df\fP (modes, rec_gyre, dic_mode_types, trim_delta_freq_factor)"
.br
.ti -1c
.RI "def \fBtrim_modes\fP (self, rec_gyre, dic_mode_types)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBdbname\fP"
.br
.ti -1c
.RI "\fBuse_constrained_sampling\fP"
.br
.ti -1c
.RI "\fBuse_random_sampling\fP"
.br
.ti -1c
.RI "\fBsampling_func_name\fP"
.br
.ti -1c
.RI "\fBsampling_func\fP"
.br
.ti -1c
.RI "\fBsampling_shuffle\fP"
.br
.ti -1c
.RI "\fBmax_sample_size\fP"
.br
.ti -1c
.RI "\fBrange_log_Teff\fP"
.br
.ti -1c
.RI "\fBrange_log_g\fP"
.br
.ti -1c
.RI "\fBrange_eta\fP"
.br
.ti -1c
.RI "\fBids_models\fP"
.br
.ti -1c
.RI "\fBids_rot\fP"
.br
.ti -1c
.RI "\fBlearning_done\fP"
.br
.ti -1c
.RI "\fBexclude_eta_column\fP"
.br
.ti -1c
.RI "\fBnum_features\fP"
.br
.ti -1c
.RI "\fBfeature_names\fP"
.br
.ti -1c
.RI "\fBlearning_ids_models\fP"
.br
.ti -1c
.RI "\fBlearning_ids_rot\fP"
.br
.ti -1c
.RI "\fBlearning_x\fP"
.br
.ti -1c
.RI "\fBlearning_y\fP"
.br
.ti -1c
.RI "\fBsample_size\fP"
.br
.ti -1c
.RI "\fBlearning_log_Teff\fP"
.br
.ti -1c
.RI "\fBlearning_log_g\fP"
.br
.ti -1c
.RI "\fBlearning_radial_orders\fP"
.br
.ti -1c
.RI "\fBlearning_mode_types\fP"
.br
.ti -1c
.RI "\fBmodes_id_types\fP"
.br
.ti -1c
.RI "\fBmodes_freq_range\fP"
.br
.ti -1c
.RI "\fBsearch_function\fP"
.br
.ti -1c
.RI "\fBsearch_for_closest_frequencies\fP"
.br
.ti -1c
.RI "\fBsearch_strictly_for_dP\fP"
.br
.ti -1c
.RI "\fBsearch_strictly_for_df\fP"
.br
.ti -1c
.RI "\fBmatch_lowest_frequency\fP"
.br
.ti -1c
.RI "\fBtrim_delta_freq_factor\fP"
.br
.ti -1c
.RI "\fBtraining_percentage\fP"
.br
.ti -1c
.RI "\fBtraining_size\fP"
.br
.ti -1c
.RI "\fBtraining_x\fP"
.br
.ti -1c
.RI "\fBtraining_y\fP"
.br
.ti -1c
.RI "\fBtraining_log_Teff\fP"
.br
.ti -1c
.RI "\fBtraining_log_g\fP"
.br
.ti -1c
.RI "\fBtraining_set_done\fP"
.br
.ti -1c
.RI "\fBcross_valid_percentage\fP"
.br
.ti -1c
.RI "\fBcross_valid_size\fP"
.br
.ti -1c
.RI "\fBcross_valid_x\fP"
.br
.ti -1c
.RI "\fBcross_valid_y\fP"
.br
.ti -1c
.RI "\fBcross_valid_log_Teff\fP"
.br
.ti -1c
.RI "\fBcross_valid_log_g\fP"
.br
.ti -1c
.RI "\fBcross_valid_set_done\fP"
.br
.ti -1c
.RI "\fBtest_percentage\fP"
.br
.ti -1c
.RI "\fBtest_size\fP"
.br
.ti -1c
.RI "\fBtest_x\fP"
.br
.ti -1c
.RI "\fBtest_y\fP"
.br
.ti -1c
.RI "\fBtest_log_Teff\fP"
.br
.ti -1c
.RI "\fBtest_log_g\fP"
.br
.ti -1c
.RI "\fBtest_set_done\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS ""
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SH ""
.PP
.PP
.SS ""



.PP
.nf
This class carries out sampling of the learning sets from the database. This class inherits the
"star.star()" object to represent a star

.fi
.PP
 
.PP
Definition at line 45 of file sampler\&.py\&.
.SH "Member Function Documentation"
.PP 
.SS "def asamba\&.sampler\&.sampling\&.build_learning_set ( self)"

.PP
Methods\&. 
.PP
.nf
This routine prepares a learning (training + cross-validation + test) set from the "tracks", "models",
and "rotation_rates" table from the database "dbname". The sampling method of the data (constrained or
unconstrained) is specified by passing the function name as "sampling_func", with the function arguments
"sampling_args".

The result from this function can be used to randomly build training, cross-validation, and/or test
sets by random slicing.

@param self: An instance of the sampling class
@type self: obj
@return: None. However, the "self.sample" attribute is set to a numpy record array whose columns are
  the following:
  - M_ini: initial mass of the model
  - fov: overshoot free parameter
  - Z: metallicity
  - logD: logarithm of extra diffusive mixing
  - Xc: central hydrogen mass fraction
  - eta: percentage rotation rate w.r.t. to the break up
@rtype: None

.fi
.PP
 
.PP
Definition at line 280 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.extract_gyre_modes_from_id_model_id_rot ( self,  list_ids_models,  list_ids_rot,  list_rows)"

.PP
.nf
This finds a GYRE outputs for a model given its id_model, and id_rot. Then, it slices the
modes based on the observed list, to ensure that there is a "reasonable" match between the
model and observed frequencies. It returns various useful info, only for those models that
survive the frequency filtering.

@param self: an instance of the sampler class
@type self: object
@param list_ids_models: is a list of the id_model for all input models
@type list_ids_models: list
@param list_ids_rot: is a list of the id_rot for all input models
@type list_ids_rot: list
@param list_rows: a list of tuples, where each tuple is e.g. (M_ini, fov, Z, logD, Xc) for
     the input models. 
@tupe list_rows: list
@return: The following items are packed into the returned data structure:
   - list of (M_ini, fov, Z, logD) attribute tuples which fulfil the trimming condition. 
   - list of id_model which fulfil the trimming condition. This is basically
     a subset of the input list.
   - List of id_rot which fulfil the trimming condition. This is basically
     a subset of the input list.
   - List of record arrays for the corresponding models which fulfil the frequency
     filtering criteria.
@rtype: tuple

.fi
.PP
 
.PP
Definition at line 375 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.get ( self,  attr)"

.PP
Getter\&. 
.PP
.nf
General-purpose method to get the value of a canonical attribute of the object
E.g.

>>>MySample = MyProblem.get('learning_x')

@param attr: the name of the available attribute of the class
@type attr: string
@return: the value of the attribute
@rtype: float

.fi
.PP
 
.PP
Definition at line 257 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.get_M_ini_fov_Z_logD_Xc_from_models_id ( self,  list_ids_models)"

.PP
.nf
This routine queries the models table in the database, and returns tuples of the global attributes
(M_ini, fov, Z, logD, Xc) that match the models.id passed by as the "list_ids_models" argument.
This routine can lie in the heart of many applications which require retrieving of the global attributes
by only providing/knowing the corresponding model id.

Note: Even if one model id is passed (repeated) several times in the following query, only the first
occurance is effective. Therefore, the size of the returned results from the following query
is a factor (len(set(ids_rot))) larger than the result of the query. Then, the problem of 1-to-1
matching is resolved by setting up a look-up dictionary, internally.

@param self: an instance of the sampler.sampling class
@type self: object
@param list_ids_models: the list of models.id (integers) giving the exact models.id as in the database
@type list_ids_models: list of integers
@return: tuples of the corresponding attributes/feature values (M_ini, fov, Z, logD, Xc) for the unique
  values in the input list_ids_models. The repeated ids will be reconstructed by walking through the
  input models.id and putting the excluded attributes back in their place.
@rtype: list of tuples

.fi
.PP
 
.PP
Definition at line 351 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.learning_log_Teff_log_g ( self)"

.PP
.nf
Fill up the "models_log_Teff" and "models_log_g" attributes of the class with the corresponding values retrieved
from the models_ids. The resulting arrays are significantly important when dealing with priors for the Bayesian
learning (see, e.g. artificial_neural_network.set_priors() method).

.fi
.PP
 
.PP
Definition at line 306 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.load_sampling_from_inlist ( self,  filename)"

.PP
.nf
Set some of the attributes of the sampling object through an inlist file. This allows to control
the behaviour of the sampling procedure in an easier way, e.g. through the frontend GUI. For every
valid input variable and its input value, the set method is called iteratively.

@param filename: Full path to the input inlist file. One example can be found in the following 
   directory: <asamba>/data/input_templates/instructions.sampling
@type filename: str
@return: None

.fi
.PP
 
.PP
Definition at line 237 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.set ( self,  attr,  val)"

.PP
Setter\&. 
.PP
.nf
Set a sampling attribute, e.g.
>>>MySample = sampler.sampling()
>>>MySample.set('range_log_Teff', [4.12, 4.27])

@param attr: The name of the attribute to set
@type attr: str
@param val: The corresponding data (type and value) for the attribute. 
   Note that the users is mainly responsible for the sanity of the input values, 
   though we internally check for some basic compatibility. The val can take any
   datatype
@type val: int, float, bool, list, etc.

.fi
.PP
 
.PP
Definition at line 181 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.split_learning_sets ( self)"

.PP
.nf
Split the learning set (prepared by calling build_learning_sets) into a training set, cross-validation
set, and a test set. To do such, the following three attributes of the "sampling" class is used (so, they
must have been already set to their non-default value):
  - training_percentage: (default -1); valid range: 0 to 100
  - cross_valid_percentage: (default -1); valid range: 0 to 100
  - test_percentage: (default -1); valid range: 0 to 100
As a result of applying this method, the following variables are set
  - training_size = -1
  - training_x = -1
  - training_y = -1

  - cross_valid_size = -1
  - cross_valid_x = -1
  - cross_valid_y = -1

  - test_size = -1
  - test_x = -1
  - test_y = -1

Note: once the training/cross-validation/test sets (i.e. *_x and *_y) are prepared, they are randomly
  shuffled internally. So, one shall never reshuffle them, else the ordering of different arrays 
  become inconsistent.

@param self: An instance of the sampling class
@type self: obj
@return: the above nine parameters will be set
@rtype: None

.fi
.PP
 
.PP
Definition at line 315 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.trim_closest_modes ( modes,  rec_gyre,  dic_mode_types,  trim_delta_freq_factor)"

.PP
Trimming Functions Note: The signatures of the following three functions must be identical, because they are tossed into self\&.search_function, and can be called from external (inherited) modules\&. 
.PP
.nf
Not developed yet 
.fi
.PP
 
.PP
Definition at line 408 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.trim_modes ( self,  rec_gyre,  dic_mode_types)"

.PP
.nf
Plan a strategy to trim the GYRE frequency list, and adapt it to the observed list based on the 
requests of the user, i.e. based on the following attributes of the sampling object: 
- search_for_closest_frequencies (Default = False)
- search_strictly_for_dP (Default = False)
- search_strictly_for_df (Default = False)
- match_lowest_frequency (Default = True)
- match_lowest_frequency (Default = 3.0)

Note: The first three booleans specify the search method, and they are all False by defult. We check
internally that only one of the flags is set to True, and the rest being False!

Note: The return value from this routine is identical to the return from the following three functions:
- _trim_closest_modes()
- _trim_modes_by_dP()
- _trim_modes_by_df()

@param self: an instance of the "sampler.sampling" class
@type self: object
@param rec_gyre: the GYRE output list of frequencies as fetched from the database. The following
     columns are available here:
     - id_model: int32
     - id_rot: int16
     - n: int16
     - id_type: int16
     - freq: float32
@type rec_gyre: np.recarray
@param dic_mode_types: Look up dictionary to match the modes identification (l, m) with the modes.id_type
  attribute in the database. This dictionary is fetched from db_lib.get_dic_look_up_mode_types_id(). 
  However, we pass it as an argument instead of fetching it internally to speed up this function.
@type dic_mode_types: dict
@return: False, if for any reason no match is found between the observed and the modeled frequency lists.
     If successful, a matching slice of the input GYRE frequency list is returned.
@rtype: np.recarray or bool

.fi
.PP
 
.PP
Definition at line 445 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.trim_modes_by_df ( modes,  rec_gyre,  dic_mode_types,  trim_delta_freq_factor)"

.PP
.nf
Not developed yet 
.fi
.PP
 
.PP
Definition at line 440 of file sampler\&.py\&.
.SS "def asamba\&.sampler\&.sampling\&.trim_modes_by_dP ( modes,  rec_gyre,  dic_mode_types,  trim_delta_freq_factor)"

.PP
.nf
As the name explains, this function receives a record array of GYRE modes summary, and trims/clips
the modes based on their period spacing pattern

@param modes: The observed modes, where each mode in the list is an instance of the "star.mode" class
@type modes: list of star.mode
@param rec_gyre: The numpy record array from GYRE frequency list coming from one GYRE output file
@type rec_gyre: np.recarray
@param dic_mode_types: Look up dictionary to match the modes identification (l, m) with the modes.id_type
  attribute in the database. This dictionary is fetched from db_lib.get_dic_look_up_mode_types_id(). 
  However, we pass it as an argument instead of fetching it internally to speed up this function.
@type dic_mode_types: dict
@param trim_delta_freq_factor: This is the fraction of the frequency difference (delta_f) between the 
  first and last observed frequencies. Default:0.25. This delta is used to select models which have
  frequencies (f) in the range [f-df*factor , f+df*factor], where df is the frequency difference between
  two consecutive modes for the lowest and highest observed modes. If this factor is set to greater than
  0.5, the theoretical modes for two neighboring modes will overlap, and that will mess up the analysis.
  In that case, we raise an exception and terminate the program.
@return: False if, for one among many reasons, it is not possible to trim the GYRE list based on the 
  observed modes. If it succeeds, the input GYRE list will be trimmed to match the size of the input
  modes, and then it will be returned.
@rtype: np.recarray or bool

.fi
.PP
 
.PP
Definition at line 413 of file sampler\&.py\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for ASAMBA from the source code\&.
