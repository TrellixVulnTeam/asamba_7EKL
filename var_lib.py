
"""
This module provides auxilary functinalities to work with the grid data, in reading, writng and 
manipulating the grid data (tracks, models, modes, etc) into a proper format. 
"""

import sys, os, glob
import logging
import numpy as np 

import var_def 

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# R O U T I N E S   F O R   M O D E L S   O B J E C T S
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def gen_histname_from_gyre_in(gyre_in_filename):
  """
  convert the full filename of the gyre_in file to a full path of the hist file, by following these 
  steps:
  1. substitute "gyre_in" with "hist"
  2. strip off the part of the filename after "logDxx.xx" 
  3. append '.hist' at the end of the file
  """
  f = gyre_in_filename
  f.replace('gyre_in', 'hist')
  ind_logD = f.rfind('logD')
  ind_keep = ind_logD + 4 + 5 + 1  # 4 for logD, 5 for the value, and 1 to shift one more character right
  f = f[:ind_keep] + '.hist'

  return f

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def prepare_models_data(self_models):
  """
  This routine prepares the necessary data needed to fill up all required fields in the "model" objects.
  For that, we use the values from the history filenames, from GYRE input filename, and from the history
  columns, as soon as we match the model_number of the input model with that of the evolution step in
  the history file.

  @param self_models: an instance of the "var_def.models" class 
  @type self_models: models object

  """
  sm = self_models

  sm.find_list_filenames()
  list_gyre_in = sm.get_list_filenames()

  # fetch "model" attribute names excluding default __doc__, __init__ and __module__
  a_model     = var_def.model()
  model_attrs = dir(a_model)
  exclude     = ['__doc__', '__init__', '__module__']
  model_attrs = [attr for attr in model_attrs if attr not in exclude]
  
  # Collect all models into a list of model objects
  list_models = []
  for i, filename in enumerate(list_gyre_in):
    # get an instance of the model class
    a_model   = var_def.model()
    a_model.set_filename(filename)

    # find the corresponding history file for this model
    histname  = gen_histname_from_gyre_in(filename)
    if not os.path.exists(histname):
      logger.error('prepare_models_data: missing the corresponding hist file {0}'.format(histname))
    dic_hist  = read_mesa_hist(histname)
    header    = dic_hist['header']
    hist      = dic_hist['hist']

    ind_slash = filename.rfind('/')
    ind_point = filename.rfind('.')
    corename  = filename[ind_slash+1 : ind_point].split('-')

    M_ini     = float(corename[0])
    fov       = float(corename[1])
    Z         = float(corename[2])
    logD      = float(corename[3])
    evol_state= corename[4]
    Xc        = float(corename[5])
    model_number  = int(corename[6])

    # get the corresponding row for this model from the hist recarray
    ind_row   = model_number - 1
    if model_number == hist['model_number'][ind_row]:
      pass
    else:
      ind_row = np.where(hist['model_number'] == model_number)[0]
    row     = hist[ind_row]

    # manually, insert the 6 above attributes to the model
    setattr(a_model, 'M_ini', M_ini)
    setattr(a_model, 'fov', fov)
    setattr(a_model, 'Z', Z)
    setattr(a_model, 'logD', logD)
    setattr(a_model, 'Xc', Xc)
    setattr(a_model, 'model_number', model_number)

    for attr in model_attrs:
      if attr in ['M_ini', 'fov', 'Z', 'logD', 'Xc', 'model_number', 'filename', 'set_by_dic', 'track']:
        continue
      else:
        setattr(a_model, attr, row[attr])

    # generate a track object, and insert it into the model
    the_track = var_def.track(M_ini=M_ini, fov=fov, Z=Z, logD=logD)
    setattr(a_model, 'track', the_track) 

    list_models.append(a_model)

  # store the list of model objects into the instance of the "models" class
  sm.set_list_models(list_models)

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# R O U T I N E S   F O R   T R A C K S   O B J E C T S
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def read_tracks_parameters_from_ascii(ascii_in):
  """
  This routine reads the contents of an ascii file which tabulates the track parameters, and returns
  a list of "var_def.track()" objects, one per each row in the file. The list can be used later on
  for any manipulation (plotting, inserting into the database, etc). Note that we skip the first row
  as the header.

  @param ascii_in: the full path to the already-available ascii file that contains the entire (or part)
         of the tracks parameters. This file can be generated by first calling the function  
         write_tracks_parameters_to_ascii().
  @type ascii_out: string
  @return: list of instances of var_def.track() class objects, one object per each row (i.e. track).
  @rtype: list
  """
  if not os.path.exists(ascii_in):
    logging.error('read_tracks_parameters_from_ascii: {0} does not exist'.format(ascii_in))

  with open(ascii_in, 'r') as r: lines = r.readlines()
  header  = lines.pop(0)
  n_lines = len(header)
  list_tracks = []

  for i, line in enumerate(lines):
    row   = line.rstrip('\r\n').split(' ')
    M_ini = float(row[0])
    fov   = float(row[1])
    Z     = float(row[2])
    logD  = float(row[3])

    a_track = var_def.track(M_ini=M_ini, fov=fov, Z=Z, logD=logD)
    list_tracks.append(a_track)

  logging.info('insert_lib: read_tracks_parameters_from_ascii exited successfully')
  print ' - insert_lib: read_tracks_parameters_from_ascii exited successfully'

  return list_tracks

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
def write_tracks_parameters_to_ascii(self_tracks, ascii_out):
  """
  Store the four parameters of the MESA tracks (mass, overshoot, metallicity and extra mixing) as
  an ascii file on the disk. To do so, the var_def.get_track_parameters() method must have already
  been applied on the var_def.tracks() class object. 
  The format of the stored file is the following: the parameters in each row correspond to one track.
  There will be four columns, separated by a single space, and they correspond to the initial mass
  (M_ini), core overshooting parameter (fov), metallicity (Z), and extra diffusive mixing (logD),
  respectively.

  @param self_tracks: an instance of the var_def.tracks()
  @type self_tracks: class object
  @param ascii_out: full path to store the track parameters.
  @type ascii_out: string
  """
  if self_tracks.n_tracks == 0:
    logging.error('insert_lib: write_tracks_parameters_to_ascii: No track data stored. Call get_track_parameters() first')

  # add a header
  lines       = ['{0:<6s} {1:<5s} {2:<5s} {3:<5s} \n'.format('M_ini', 'fov', 'Z', 'logD')]

  list_tracks = self_tracks.list_tracks
  for i, obj in enumerate(list_tracks):
    str_M_ini = '{0:06.3f}'.format(obj.M_ini)
    str_fov   = '{0:05.3f}'.format(obj.fov)
    str_Z     = '{0:05.3f}'.format(obj.Z)
    str_logD  = '{0:05.2f}'.format(obj.logD)
    line      = '{0} {1} {2} {3} \n'.format(str_M_ini, str_fov, str_Z, str_logD)
    lines.append(line)

  with open(ascii_out, 'w') as w: w.writelines(lines)
  logging.info('insert_lib: write_tracks_parameters_to_ascii saved {0}'.format(ascii_out))
  print ' - insert_lib: write_tracks_parameters_to_ascii saved {0}'.format(ascii_out)

  return True

#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
